---
layout: post
title: "流密码总结"
date: 2019-07-26
excerpt: "关于流密码的一些总结，持续更新中"
tag:
- Stream Cipher
- Crypto
comments: true
---

---

* TOC
{:toc}
---

## 流密码的基本概念

流密码的基础思想是**利用密钥k产生一个密钥流** $$ z = z_0z_1\cdots $$, **并使用如下规则对明文串** $$ x = x_0x_1x_2\cdots $$ **加密：**$$ y = y_0y_1y_2\cdots = E_{z_0}(x_0)E_{z_1}(x_1)E_{z_2}(x_2)\cdots $$。密钥流由密钥流发生器 $$ f $$ 产生：$$ z_i = f(k, \sigma_i) $$，这里 $$ \sigma_i $$ 是加密器中的记忆元件(存储器)在时刻 $$ i $$ 的状态，$$ f $$ 是由密钥 $$ k $$ 和 $$ \sigma_i $$ 产生的函数。

分组密码和流密码的区别在于**有无记忆性**。流密码的滚动密钥 $$ z_0 = f(k, \sigma_0) $$ 由函数 $$ f $$、密钥 $$ k $$ 指定的初态 $$ \sigma_0 $$ 完全确定。伺候，由于输入加密器的明文可能影响加密器中内部记忆元件的存储状态，因而 $$ \sigma_i(i > 0) $$ 可能依赖于 $$ k, \sigma_0, x_0, \cdots, x_{i - 1} $$等参数。

![comparison between block cipher and stream cipher](https://i.loli.net/2019/07/26/5d3abc9497b2048474.png)

### 同步流密码

根据**加密器中记忆元件的存储状态 $$ \sigma_i $$**是否依赖于输入的明文字符，流密码进一步分成**同步**和**自同步**两种。$$ \sigma_i $$ 独立于明文字符的叫做同步流密码，否则叫做自同步流密码。由于自同步流密码的密钥流的产生与明文有关，因而较难从理论上进行分析。目前大多数研究成果都是关于同步流密码的。

在有限域 $$GF(2) $$ 上讨论的二元加法流密码是目前最为常用的流密码体制，其加密变换可表示为 $$y_i = z_i \oplus x_i$$。

![add stream cryptosystem model](https://i.loli.net/2019/07/26/5d3abcf42774193542.png)

加法流密码的原型是一次一密密码。在实际使用中，密码设计者希望密钥 $$ k $$ 经过密钥生成器拓展得到的密钥流序列 $$ z $$ 具有如下的性质：**极大的周期，良好的统计特性，抗线性分析，抗统计分析**。



### 有限状态自动机

有限状态自动机是具有离散输入和输出(输入集和输出集均有限)的一种数学模型，由以下3部分组成：

1. 有限状态集 $$ S = \{s_i \mid i = 1, 2, \cdots, l\} $$;
2. 有限输入字符集 $$ A_1 = \{A_j^{(1)} \mid 1, 2, \cdots, m\} $$ 和有限输出字符集 $$ A_2 = \{A_k^{(2)} \mid k = 1, 2, \cdots, n\} $$;
3. 转移函数 $$ A_k^{(2)} = f_1(s_i, A_j^{(1)}), s_h = f_2(s_i, A_j^{(1)}) $$

即在状态为 $$ s_i $$，输入为 $$ A_j^{(1)} $$，输出为 $$ A_k^{(2)} $$, 而状态转移为 $$ s_h $$。

有限状态自动机可以用有向图表示，称为转移图。转移图的顶点对应于自动机的状态，若状态 $$ s_i $$ 在输入 $$ A_j^{(1)} $$ 时转为状态 $$ s_j $$，且输出一个字符 $$ A_k^{(2)} $$，则在转移图中，从状态 $$ s_i $$到状态 $$ s_j $$ 有一条标有($$ A_j^{(1)} $$, $$ A_k^{(2)} $$) 的弧线。

> 例:![finite state automata](https://i.loli.net/2019/07/26/5d3ab4987743857572.png)
>
> 若输入序列为 $$ A_1^{(1)}A_2^{(1)}A_1^{(1)}A_3^{(1)}A_3^{(1)}A_1^{(1)} $$，初始状态为 $$s_1$$，则得到状态序列 $$ s_1s_2s_2s_3s_2s_1s_2 $$ 输出字符序列 $$ A_1^{(2)}A_1^{(2)}A_2^{(2)}A_1^{(2)}A_3^{(2)}A_1^{(2)} $$



### 密钥流产生器

同步流密码的关键是**密钥流产生器**。一般可以将其看成一个参数为 $$ k $$ 的有限状态自动机，由一个输出符号集 $$ Z $$、一个状态集 $$ \sum $$、两个函数 $$ \varphi $$ 和 $$ \phi $$ 以及一个初始状态 $$ \sigma_0 $$ 组成。状态转移函数 $$ \varphi: \sigma_i \to \sigma_{i + 1} $$，将当前状态 $$ \sigma_i $$ 变为一个新状态 $$ \sigma_{i + 1} $$，输出函数 $$ \phi: \sigma_i \to z_i $$，当前状态 $$ \sigma_i $$ 变为输出符号集的一个元素 $$ z_i $$。这种密钥流生成器设计的关键在于找出适当的状态转移函数 $$ \varphi $$ 和输出函数 $$ \phi $$，使得输出序列 $$ z $$ 满足密钥流序列 $$ z $$应满足的几个条件，并且要求在设备上是节省的和容易实现的。

![key flow generator for finite state automata](https://i.loli.net/2019/07/26/5d3abd4a2b11795740.png)

为了实现这一目标现在常用的方法是采用线性的 $$ \varphi $$ 和非线性的 $$ \phi $$，可以将其分成驱动部分和非线性组合部分。驱动部分控制生成器的状态转移，并为非线性组合部分提供统计性能好的序列。而非线性组合部分要利用这些序列组合出满足要求的密钥流序列。

---

## 线性反馈移位寄存器

移位寄存器是流密码产生密钥流的一个主要组成部分。$$ GF(2) $$ 上一个 $$ n $$ 及反馈移位寄存器由 $$ n $$ 个二元存储器与一个反馈函数 $$ f(a_1, a_2, \cdots, a_n) $$ 组成。每一存储器称为移位存储器的一**级**，在任一时刻，这些级的内容构成该反馈移位寄存器的**状态**，每一状态对应于 $$ GF(2) $$ 上的一个 $$ n $$ 维向量, 共有 $$ 2^n $$ 种可能的状态。 每一时刻的状态可用 **$$ n $$ 长序列** $$ a_1, a_2, \cdots, a_n $$ 或**$$ n $$ 维向量** $$ (a_1, a_2, \cdots, a_n) $$ 表示，其中 $$ a_i $$ 是第 $$ i $$ 级存储器的内容。**初始状态**由用户确定，当第 $$ i $$ 个移位时钟脉冲到来时，每一级存储器 $$ a_i $$ 都将其内容向下一级 $$ a_{i - 1} $$ 传递，并根据寄存器此时的状态 $$ a_1, a_2, \cdots, a_n $$ 计算 $$ f(a_1, a_2, \cdots, a_n) $$，作为下一时刻的 $$ a_n $$。反馈函数 $$ f(a_1, a_2, \cdots, a_n) $$ 是 $$ n $$ 元布尔函数，即 $$ n $$ 个变元 $$ a_1, a_2, \cdots, a_n $$ 可以独立地取`0`和`1`这两个可能的值，函数中的运算有逻辑与、逻辑或、逻辑补等运算，最后的函数值也为`0`或`1`。

![n-order linear feedback shift register](https://i.loli.net/2019/07/29/5d3ea8844185957912.png)

> 例：
>
> 一个三级反馈移位寄存器，其初始状态为 $$ (a_1, a_2, a_3) = (1, 0, 1) $$，其状态和输出见下表
>
> ![3-order linear feedback shift register](https://i.loli.net/2019/07/29/5d3eaa69db4ca98332.png)
>
> | 状态 $$ (a_3, a_2, a_1) $$ |  $$ a_3 $$   |  $$ a_2 $$   |  $$ a_1 $$   |     输出     |
> | :------------------------: | :----------: | :----------: | :----------: | :----------: |
> |         (1, 0, 1)          |      1       |      0       |      1       |      1       |
> |         (1, 1, 0)          |      1       |      1       |      0       |      0       |
> |         (1, 1, 1)          |      1       |      1       |      1       |      1       |
> |         (0, 1, 1)          |      0       |      1       |      1       |      1       |
> |         (1, 0, 1)          |      1       |      0       |      1       |      1       |
> |         (1, 1, 0)          |      1       |      1       |      0       |      0       |
> |        $$ \vdots $$        | $$ \vdots $$ | $$ \vdots $$ | $$ \vdots $$ | $$ \vdots $$ |
>
> 即输出序列为 $$ 101110\cdots $$，周期为 $$ 4 $$

如果移位寄存器的反馈函数 $$ f(a_1, a_2, \cdots, a_n) $$ 是 $$ a_1, a_2, \cdots, a_n $$ 的线性函数，则称之为线性反馈移位寄存器(Linear Feedback Shift Register, LFSR)。此时 $$ f $$ 可写为


$$
f(a_1, a_2, \cdots, a_n) = c_na_1 \oplus c_{n-1}a_2 \oplus \cdots \oplus c_1a_n
$$


其中常数 $$ c_i = 0\ or\ 1 $$，$$ \oplus $$ 是模2加法。

输出序列 $$ \{a_t\} $$ 满足


$$
a_{n+t} = c_na_t \oplus c_{n-1}a_{t+1} \oplus \cdots \oplus c_1a_{n+t-1}
$$
其中t为非负正整数。

在线性反馈移位寄存器中总是假定 $$ c_1, c_2, \cdots, c_n $$ 中至少有一个不为0，否则 $$ f(a_1, a_2, \cdots, a_n) \equiv 0 $$ 这样的话，在n个脉冲后状态必然全为0，且这种状态将一直保持下去。若只有一个系数不为0，实际上其实就是一个延迟装置。

线性反馈移位寄存器输出序列的性质完全由其**反馈函数**决定。n级线性反馈移位寄存器最多有 $$ 2^n $$ 个不同的状态。若其初始状态为0，则其状态恒为0。因此n级线性反馈移位寄存器的状态周期小于等于 $$ 2^n - 1 $$。其输出序列的周期与状态周期相等，也小于等于 $$ 2^n - 1 $$。周期达到最大值的序列称为**m序列**。

---

## 线性反馈移位寄存器的一元多项式表示

设n级线性反馈移位寄存器的输出序列 $$ \{a_i\} $$ 满足递推关系


$$
a_{n+t} = c_na_t \oplus c_{n-1}a_{t+1} \oplus \cdots \oplus c_1a_{n+t-1}
$$


对任何 $$ t \ge 1 $$ 成立。这种递推关系可用一元高次多项式


$$
p(x) = 1 + c_1x + \cdots + c_{n-1}x^{n-1} + c_nx^n
$$

表示，称这个多项式为LFSR的互反多项式，
$$
f(x)=x^n-\sum\limits_{i=1}^{n}c_ix^{n-i}
$$


非零n级线性反馈移位寄存器对应的 $$ 2^n - 1 $$ 个序列记为 $$ G(p(x)) $$。



1. 给定序列 $$ \{a_i\} $$，幂级数 $$ A(x) = \sum\limits_{i=1}^\propto a_ix^{i-1} $$ 称为该序列的生成函数。
2. 设 $$ p(x) = 1 + c_1x + \cdots + c_{n-1}x^{x-1} + c_nx^n $$ 是 $$ GF(2) $$ 上的多项式，$$ G(p(x)) $$ 中任一序列 $$ \{a_i\} $$ 的生成函数 $$ A(x) $$ 满足：$$ A(x) = \frac{\phi(x)}{p(x)} $$，其中 $$ \phi(x) = \sum\limits_{i=1}^n(c_{n-i}x^{n-i}\sum\limits_{j=1}^ia_jx^{j-1}) $$
3. $$ p(x) \mid q(x) $$ 的充要条件是 $$ G(p(x)) \subset G(q(x)) $$。
4. 设 $$ p(x) $$ 是 $$ GF(2) $$ 上的多项式，使 $$ p(x) \mid (x^p - 1) $$ 的最小 $$ p $$ 称为 $$ p(x) $$ 的周期或阶。
5. 若序列 $$ \{a_i\} $$ 的特征多项式 $$ p(x) $$ 定义在 $$ GF(2) $$ 上，$$ p $$ 是 $$ p(x) $$ 的周期，则称 $$ \{a_i\} $$ 的周期 $$ r \mid p $$。
6. 仅能被非0常数或自身的常数倍除尽，但不能被其他多项式除尽的多项式称为即约多项式或不可约多项式。
7. 设 $$ p(x) $$ 是n次不可约多项式，周期为m，序列 $$ \{a_i\} \in G(p(x)) $$，则 $$ \{a_i\} $$ 的周期为m。
8. n级LFSR产生的序列有最大周期 $$ 2^n - 1 $$ 的必要条件时**其特征多项式为不可约的**。 
9. 若n次不可约多项式 $$ p(x) $$ 的阶为 $$ 2^n -1  $$，则称 $$ p(x) $$ 为**本原多项式**。
10. 设 $$ \{a_i\} \in G(p(x)) $$， $$ \{a_i\} $$为m序列的**充要条件是 $$ p(x) $$ 为本原多项式**。

---

## m序列的为随机性

流密码的安全性取决于**密钥流的安全性**。

$$ GF(2) $$ 上周期为 T 的序列 $$ \{a_i\} $$ 的自相关函数定义为
$$
R(\tau) = \frac{1}{T}\sum\limits_{k=1}^T(-1)^{a_k}(-1)^{a_{k+r}}, 0 \le \tau \le T-1
$$
位得到和式表示序列 $$ \{a_i\} $$ 与 $$ \{a_{i+\tau}\} $$ (序列 $$ \{a_i\} $$ 向后平移 $$ \tau $$)在一个周期内对应位相同的位数与对应位不同的位数之差。当 $$ \tau = 0 时，R(\tau) = 1; 当 \tau \ne 0 时，称 R(\tau) 为异相自相关函数 $$。 

**Golomb随机性公设**

对伪随机周期序列提出了应满足如下3个随机性公设：

1. 在序列的一个周期内，0与1的个数相差至多为1。
2. 在序列的一个周期内，长为1的游程占游程总数的 $$ \frac{1}{2} $$，长为2的游程占游程总数的 $$ \frac{1}{2^2}, \cdots,  $$ 长为 i 的游程占游程总数的 $$ \frac{1}{2^i}, \cdots, $$ 且在等长的游程中 0 的游程个数与 1 的游程个数相等。
3. 异自相关函数是一个常数

公设 1 说明 $$ \{a_i\} $$ 中 0 与 1 出现的概率基本上相同；公设 2 说明 0 与 1 在序列中每一位置上出现的概率相同；公设 3 说明通过对序列与其平移后的序列作比较，不能给出其他任何信息。

从密码系统的角度来看，一个伪随机序列还应该满足：

4. $$ \{a_i\} $$ 的周期相当大。
5. $$ \{a_i\} $$ 的确定在计算上是容易的。
6. 由密文及相应的明文的部分信息，不能确定整个 $$ \{a_i\} $$。



$$ GF(2) $$ 上的 n 长 m 序列 $$ \{a_i\} $$ 具有如下性质：

1. 在一个周期内， 0、1出现的次数分别为 $$ 2^{n-1} - 1和 2^{n-1} $$；
2. 在一个周期内，总游程数为 $$ 2^{n-1} $$；对 $$ 1 \le i \le n-2 $$，长为 i 的游程有 $$ 2^{n-i-1} $$ 个，且 0、1 游程各半；长为 $$ n-1 $$ 的 0 游程一个，长为 $$ n $$ 的 1 游程一个；
3. $$ \{a_i\} $$ 的自相关函数为

$$
R(\tau) = 
\begin{cases}
1, \tau = 0\\
-\frac{1}{2^n-1}, \tau \in (0, 2^n-2]
\end{cases}
$$

---

## m序列的破译

### Berlekamp-Massey algorithm

![Berlekamp-Massey algorithm](https://i.loli.net/2019/08/01/5d424cae0955716735.png)

[python script for Berlekamp-Massey algorithm](https://raw.githubusercontent.com/bozhu/BMA/master/bma.py)

### Another solution

如果已知长度为 2n 的序列，假设已知的序列为 $$ a_1, \cdots, a_{2n} $$，那么我们可以令


$$
S_1 = (a_1, a_2, \cdots, a_n) \\
S_2 = (a_2, a_3, \cdots, a_{n+1}) \\
\vdots \\
S_{n+1} = (a_{n+1}, a_{n+2}, \cdots, a_{2n})
$$


那么我们可以构造矩阵 $$ X = (S_1, S_2, \cdots, S_n) $$，那么


$$
S_{n+1} = (c_n, c_{n-1}, \cdots, c_1)X
$$


所以


$$
(c_n, c_{n-1}, \cdots, c_1) = S_{n+1}X^{-1}
$$

> 例:
>
> 假定有密钥流 11010 01000，并且已知是使用 5 级线性反馈移位寄存器产生的，那么可以通过如下的方案得到反馈多项式
>
> - 利用前 10 个比特建立如下方程
>
> $$
> \begin{pmatrix}
> a_6a_7a_8a_9a_{10}
> \end{pmatrix} = 
> \begin{pmatrix}
> c_5c_4c_3c_2c_1
> \end{pmatrix}
> \begin{pmatrix}
> a_1a_2a_3a_4a_5 \\
> a_2a_3a_4a_5a_6 \\
> a_3a_4a_5a_6a_7 \\
> a_4a_5a_6a_7a_8 \\
> a_5a_6a_7a_8a_9
> \end{pmatrix}
> $$
>
> 即
>
> 
> $$
> \begin{pmatrix}
> 01000
> \end{pmatrix} = 
> \begin{pmatrix}
> c_5c_4c_3c_2c_1
> \end{pmatrix}
> \begin{pmatrix}
> 11010 \\
> 10100 \\
> 01001 \\
> 10010 \\
> 00100
> \end{pmatrix}
> $$
> 
>
> 从而有
> $$
> \begin{pmatrix}
> c_5c_4c_3c_2c_1
> \end{pmatrix} = 
> \begin{pmatrix}
> 10010
> \end{pmatrix}
> $$

---

## 快速相关攻击

### 攻击模型

设目标 `LFSR` 的反馈多项式 $$ f(x) $$ 是已知的，级数为 `l`，抽头数(重量)为 `t`。对于固定的输出长度 `N`，目标 LFSR 的输出序列 $$ \{a_n\} $$ 可以视作一个 [N, L] 线性分组码。由于非线性组合函数的输入分量和输出分量间存在相关性，即 $$ p(a_i = z_i) = p $$，可将密钥流序列 $$ \{z_n\} $$ 看作是线性分组码 $$ \{a_n\} $$ 经过错误率为 $$ 1 - p $$ 的二进制无记忆信道传输后的结果。因此可以把密钥流的破译看成是一个线性分组码的译码问题。

![BSC model for fast correlation attacks](https://i.loli.net/2019/07/30/5d3ff4b4db27115842.png)

### M-S算法A

#### 算法流程

对 $$ \{a_n\} $$ 中的任一比特 $$ a_i $$，根据低重量多项式的性质 $$ f(x)^{2i} = f(x^{2i}) $$，从 $$ f(x) $$ 的倍式中得到 m 个校验等式，计算关于 $$ z_i $$ 的 m 个校验等式中，至少有 h 个成立的概率


$$
Q(p, m, h) = \sum\limits_{i = h}^m \binom {m}{i}(ps^i(1-s)^{m-i} + (1-p)(1-s)^is^{m-i})
$$


计算 $$ z_i $$ 至少满足 h 个校验等式，且 $$ a_i = z_i $$ 的概率：


$$
R(p, m, h) = \sum\limits _{i = h}^m \binom {m}{i} ps^i(1-s)^{m-i}
$$


所以在给定 m 个方程中，$$ z_i $$ 至少满足 h 个校验等式是，$$ a_i = z_i $$ 的概率：


$$
T(p, m, h) = \frac{R(p, m, h)}{Q(p, m, h)}
$$


计算使得 $$ Q(p, m, h)  \cdot N \ge L $$ 中最大的 h，记为 $$ h_{max} $$；从 $$ \{z_n\} $$ 中选取至少满足 $$ h_{max} $$ 个校验等式的 L 个 $$ z_i $$作为对应 $$ a_i $$ 的估计，记为 $$ I_0 $$；根据 $$ \{a_n\} 和 \{z_n\} $$ 的相关性判断 $$ I_0 $$ 是否正确，如不正确，加上重量为 $$ 1, 2, 3, \cdots $$ 的矢量进行修正，直到找到正确解。

#### 算法实现

---

## 代数攻击



---

## 采样攻击

暂时没有理解原理

![decimation_attack.png](https://i.loli.net/2019/08/08/PxIhFoqQfZWwcMD.png)

截图来自[《序列密码采样攻击的改进方法》](http://www.cqvip.com/qk/95200x/200908/30109051.html)

需要得到原始序列初态表示的线性组合就需要知道原始序列的反馈表达式，既然知道原始序列的反馈表达式，不就可以直接得到原始序列的初始状态了么？还采样干嘛。。。emmm理解不能 orz

---

> 参考文献：《现代密码学》(第四版)
>
> 参考文献：《Serious Cryptography》