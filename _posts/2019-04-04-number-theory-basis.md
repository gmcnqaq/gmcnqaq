---
layout: post
title: "数论基础"
date: 2019-04-04
excerpt: "介绍一些基础概念"
tag:
- Number Theory
- Crypto
comments: true
---

---

## 整除性和带余除法

### 整除性

设a,b, m均为整数，其中b ≠ 0, 若存在某个m使得$a = mb$成立, 则称**b整除a**

也就是说如果b除a没有余数, 则认为b整除a

b除a通常用`b | a`表示, 同时若b \| a, 我们就说b是a的一个**因子**

关于整数整除我们有如下的一些简单的性质:

* 若a \| 1, 则a = ±1
* 若a \| b, 且b \| a, 则a = ±b
* 0是任何非零整数的倍数, ±1是任何非零整数的因子
* 若a \| b且b \| c, 则a \| c
* 对于任意整数m, n, 若b \| g且b \| h, 则可以得出b \| (mg + nh)

### 带余除法

对于a, b两个整数, 其中b ≠ 0, 则 `a = qb + r`, 0 ≤ r ≤ \|b\|. 则称r为a被b除得到的**余数**

显然当 r = 0时, b \| a

---

## 欧几里得算法

```python
def gcd(a, b):
    if a % b == 0:
        return b
    else:
        return gcd(b, a % b)
```

例:
$$a = 888, b = 264$$

$$888 = 2 * 312 + 264$$

$$312 = 1 * 264 + 48$$

$$264 = 5 * 48 + 24$$

$$48 = 2 * 24$$

$$gcd(264, 888) = 24$$

---

## 模运算

### 模

如果a是一个整数, n是正整数, 则我们定义a除以n所得的余数为**a模n**，整数n称为模数

### 同余

`a ≡ b (mod n)`

对同余的理解: 从采用的`≡`, 即可理解其含义，即: *在mod n运算时a与b是**等价**的*

### 模运算

性质

* $$[(a\  mod\  n) + (b\  mod\  n)]\ mod\ n = (a + b)\ mod\ n$$ ①
* $$[(a\  mod\  n) * (b\  mod\  n)]\ mod\ n = (a * b)\ mod\ n$$ ②
* 若a与n互素: 若$$(a * b) ≡ (a * c)\ mod\ n$$, 则$$b ≡ c\ mod\ n$$ ③


定义比n小的非负整数集合为$$Z_n$$

$$Z_n = \{0, 1, \dots, (n - 1)\}$$

这个集合称为**剩余类集**, 或模n的剩余类，更确切的说, $$Z_n$$中的每个整数都代表一个剩余类, 我们可以将模n的剩余类表示为[0], [1], [2], ..., [n - 1]

在剩余类的所有整数中，我们通常用最小非负整数来代表这个剩余类

### 拓展欧几里得算法
```python
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)
```
例:$$a = 264, b = 888$$

$$264 = 888 - 2 * 312$$

$$48 = 312 - 264 = 312 - (888 - 2 * 312) = -888 + 3 * 312$$

$$24 = 264 - 5 * 48 = (888 - 2 * 312) - 5 * (-888 + 3 * 312) = 6 * 888 - 17 * 312$$

---

## 素数

**整数p > 1是素数, 当且仅当它只有因子±1和±p**

**算数基本定理**: 任何整数a > 1都可以唯一地因式分解为

$$a = p_1^{a_1} * p_2^{a_2} * \dots * p_t^{a_t}$$

式中$$p_1, p_2, \dots, p_t$$均是素数, $$p_1 < p_2 < \dots < p_t$$, 且所有的$$a_i$$都是正整数

另一种表示方法:

设P是所有素数的集合,则任意正整数a可以唯一地表示为

$$a = \prod_{p\in P} {p^{a_p}}, a_p \ge 0$$

上式右边是所有可能素数p之积

> 参考文献: 《密码编码学与网络安全--原理与实践(第七版)》